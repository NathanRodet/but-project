{"ast":null,"code":"/**\r\n * mux.js\r\n *\r\n * Copyright (c) Brightcove\r\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n *\r\n * A lightweight readable stream implemention that handles event dispatching.\r\n * Objects that inherit from streams should call init in their constructors.\r\n */\n'use strict';\n\nvar Stream = function Stream() {\n  this.init = function () {\n    var listeners = {};\n    /**\r\n     * Add a listener for a specified event type.\r\n     * @param type {string} the event name\r\n     * @param listener {function} the callback to be invoked when an event of\r\n     * the specified type occurs\r\n     */\n\n    this.on = function (type, listener) {\n      if (!listeners[type]) {\n        listeners[type] = [];\n      }\n\n      listeners[type] = listeners[type].concat(listener);\n    };\n    /**\r\n     * Remove a listener for a specified event type.\r\n     * @param type {string} the event name\r\n     * @param listener {function} a function previously registered for this\r\n     * type of event through `on`\r\n     */\n\n\n    this.off = function (type, listener) {\n      var index;\n\n      if (!listeners[type]) {\n        return false;\n      }\n\n      index = listeners[type].indexOf(listener);\n      listeners[type] = listeners[type].slice();\n      listeners[type].splice(index, 1);\n      return index > -1;\n    };\n    /**\r\n     * Trigger an event of the specified type on this stream. Any additional\r\n     * arguments to this function are passed as parameters to event listeners.\r\n     * @param type {string} the event name\r\n     */\n\n\n    this.trigger = function (type) {\n      var callbacks, i, length, args;\n      callbacks = listeners[type];\n\n      if (!callbacks) {\n        return;\n      } // Slicing the arguments on every invocation of this method\n      // can add a significant amount of overhead. Avoid the\n      // intermediate object creation for the common case of a\n      // single callback argument\n\n\n      if (arguments.length === 2) {\n        length = callbacks.length;\n\n        for (i = 0; i < length; ++i) {\n          callbacks[i].call(this, arguments[1]);\n        }\n      } else {\n        args = [];\n        i = arguments.length;\n\n        for (i = 1; i < arguments.length; ++i) {\n          args.push(arguments[i]);\n        }\n\n        length = callbacks.length;\n\n        for (i = 0; i < length; ++i) {\n          callbacks[i].apply(this, args);\n        }\n      }\n    };\n    /**\r\n     * Destroys the stream and cleans up.\r\n     */\n\n\n    this.dispose = function () {\n      listeners = {};\n    };\n  };\n};\n/**\r\n * Forwards all `data` events on this stream to the destination stream. The\r\n * destination stream should provide a method `push` to receive the data\r\n * events as they arrive.\r\n * @param destination {stream} the stream that will receive all `data` events\r\n * @param autoFlush {boolean} if false, we will not call `flush` on the destination\r\n *                            when the current stream emits a 'done' event\r\n * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\r\n */\n\n\nStream.prototype.pipe = function (destination) {\n  this.on('data', function (data) {\n    destination.push(data);\n  });\n  this.on('done', function (flushSource) {\n    destination.flush(flushSource);\n  });\n  this.on('partialdone', function (flushSource) {\n    destination.partialFlush(flushSource);\n  });\n  this.on('endedtimeline', function (flushSource) {\n    destination.endTimeline(flushSource);\n  });\n  this.on('reset', function (flushSource) {\n    destination.reset(flushSource);\n  });\n  return destination;\n}; // Default stream functions that are expected to be overridden to perform\n// actual work. These are provided by the prototype as a sort of no-op\n// implementation so that we don't have to check for their existence in the\n// `pipe` function above.\n\n\nStream.prototype.push = function (data) {\n  this.trigger('data', data);\n};\n\nStream.prototype.flush = function (flushSource) {\n  this.trigger('done', flushSource);\n};\n\nStream.prototype.partialFlush = function (flushSource) {\n  this.trigger('partialdone', flushSource);\n};\n\nStream.prototype.endTimeline = function (flushSource) {\n  this.trigger('endedtimeline', flushSource);\n};\n\nStream.prototype.reset = function (flushSource) {\n  this.trigger('reset', flushSource);\n};\n\nmodule.exports = Stream;","map":{"version":3,"sources":["C:/Users/franc/Documents/GitHub/but-project/node_modules/mux.js/lib/utils/stream.js"],"names":["Stream","init","listeners","on","type","listener","concat","off","index","indexOf","slice","splice","trigger","callbacks","i","length","args","arguments","call","push","apply","dispose","prototype","pipe","destination","data","flushSource","flush","partialFlush","endTimeline","reset","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * mux.js\r\n *\r\n * Copyright (c) Brightcove\r\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n *\r\n * A lightweight readable stream implemention that handles event dispatching.\r\n * Objects that inherit from streams should call init in their constructors.\r\n */\r\n'use strict';\r\n\r\nvar Stream = function() {\r\n  this.init = function() {\r\n    var listeners = {};\r\n    /**\r\n     * Add a listener for a specified event type.\r\n     * @param type {string} the event name\r\n     * @param listener {function} the callback to be invoked when an event of\r\n     * the specified type occurs\r\n     */\r\n    this.on = function(type, listener) {\r\n      if (!listeners[type]) {\r\n        listeners[type] = [];\r\n      }\r\n      listeners[type] = listeners[type].concat(listener);\r\n    };\r\n    /**\r\n     * Remove a listener for a specified event type.\r\n     * @param type {string} the event name\r\n     * @param listener {function} a function previously registered for this\r\n     * type of event through `on`\r\n     */\r\n    this.off = function(type, listener) {\r\n      var index;\r\n      if (!listeners[type]) {\r\n        return false;\r\n      }\r\n      index = listeners[type].indexOf(listener);\r\n      listeners[type] = listeners[type].slice();\r\n      listeners[type].splice(index, 1);\r\n      return index > -1;\r\n    };\r\n    /**\r\n     * Trigger an event of the specified type on this stream. Any additional\r\n     * arguments to this function are passed as parameters to event listeners.\r\n     * @param type {string} the event name\r\n     */\r\n    this.trigger = function(type) {\r\n      var callbacks, i, length, args;\r\n      callbacks = listeners[type];\r\n      if (!callbacks) {\r\n        return;\r\n      }\r\n      // Slicing the arguments on every invocation of this method\r\n      // can add a significant amount of overhead. Avoid the\r\n      // intermediate object creation for the common case of a\r\n      // single callback argument\r\n      if (arguments.length === 2) {\r\n        length = callbacks.length;\r\n        for (i = 0; i < length; ++i) {\r\n          callbacks[i].call(this, arguments[1]);\r\n        }\r\n      } else {\r\n        args = [];\r\n        i = arguments.length;\r\n        for (i = 1; i < arguments.length; ++i) {\r\n          args.push(arguments[i]);\r\n        }\r\n        length = callbacks.length;\r\n        for (i = 0; i < length; ++i) {\r\n          callbacks[i].apply(this, args);\r\n        }\r\n      }\r\n    };\r\n    /**\r\n     * Destroys the stream and cleans up.\r\n     */\r\n    this.dispose = function() {\r\n      listeners = {};\r\n    };\r\n  };\r\n};\r\n\r\n/**\r\n * Forwards all `data` events on this stream to the destination stream. The\r\n * destination stream should provide a method `push` to receive the data\r\n * events as they arrive.\r\n * @param destination {stream} the stream that will receive all `data` events\r\n * @param autoFlush {boolean} if false, we will not call `flush` on the destination\r\n *                            when the current stream emits a 'done' event\r\n * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\r\n */\r\nStream.prototype.pipe = function(destination) {\r\n  this.on('data', function(data) {\r\n    destination.push(data);\r\n  });\r\n\r\n  this.on('done', function(flushSource) {\r\n    destination.flush(flushSource);\r\n  });\r\n\r\n  this.on('partialdone', function(flushSource) {\r\n    destination.partialFlush(flushSource);\r\n  });\r\n\r\n  this.on('endedtimeline', function(flushSource) {\r\n    destination.endTimeline(flushSource);\r\n  });\r\n\r\n  this.on('reset', function(flushSource) {\r\n    destination.reset(flushSource);\r\n  });\r\n\r\n  return destination;\r\n};\r\n\r\n// Default stream functions that are expected to be overridden to perform\r\n// actual work. These are provided by the prototype as a sort of no-op\r\n// implementation so that we don't have to check for their existence in the\r\n// `pipe` function above.\r\nStream.prototype.push = function(data) {\r\n  this.trigger('data', data);\r\n};\r\n\r\nStream.prototype.flush = function(flushSource) {\r\n  this.trigger('done', flushSource);\r\n};\r\n\r\nStream.prototype.partialFlush = function(flushSource) {\r\n  this.trigger('partialdone', flushSource);\r\n};\r\n\r\nStream.prototype.endTimeline = function(flushSource) {\r\n  this.trigger('endedtimeline', flushSource);\r\n};\r\n\r\nStream.prototype.reset = function(flushSource) {\r\n  this.trigger('reset', flushSource);\r\n};\r\n\r\nmodule.exports = Stream;\r\n"]},"metadata":{},"sourceType":"script"}
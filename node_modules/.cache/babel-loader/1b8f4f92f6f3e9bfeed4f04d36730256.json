{"ast":null,"code":"/*! @name @videojs/vhs-utils @version 2.3.0 @license MIT */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar window = _interopDefault(require('global/window'));\n\nvar regexs = {\n  // to determine mime types\n  mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,\n  webm: /^(vp0?[89]|av0?1|opus|vorbis)/,\n  ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,\n  // to determine if a codec is audio or video\n  video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,\n  audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3)/,\n  text: /^(stpp.ttml.im1t)/,\n  // mux.js support regex\n  muxerVideo: /^(avc0?1)/,\n  muxerAudio: /^(mp4a)/,\n  // match nothing as muxer does not support text right now.\n  // there cannot never be a character before the start of a string\n  // so this matches nothing.\n  muxerText: /a^/\n};\nvar mediaTypes = ['video', 'audio', 'text'];\nvar upperMediaTypes = ['Video', 'Audio', 'Text'];\n/**\r\n * Replace the old apple-style `avc1.<dd>.<dd>` codec string with the standard\r\n * `avc1.<hhhhhh>`\r\n *\r\n * @param {string} codec\r\n *        Codec string to translate\r\n * @return {string}\r\n *         The translated codec string\r\n */\n\nvar translateLegacyCodec = function translateLegacyCodec(codec) {\n  if (!codec) {\n    return codec;\n  }\n\n  return codec.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (orig, profile, avcLevel) {\n    var profileHex = ('00' + Number(profile).toString(16)).slice(-2);\n    var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);\n    return 'avc1.' + profileHex + '00' + avcLevelHex;\n  });\n};\n/**\r\n * Replace the old apple-style `avc1.<dd>.<dd>` codec strings with the standard\r\n * `avc1.<hhhhhh>`\r\n *\r\n * @param {string[]} codecs\r\n *        An array of codec strings to translate\r\n * @return {string[]}\r\n *         The translated array of codec strings\r\n */\n\n\nvar translateLegacyCodecs = function translateLegacyCodecs(codecs) {\n  return codecs.map(translateLegacyCodec);\n};\n/**\r\n * Replace codecs in the codec string with the old apple-style `avc1.<dd>.<dd>` to the\r\n * standard `avc1.<hhhhhh>`.\r\n *\r\n * @param {string} codecString\r\n *        The codec string\r\n * @return {string}\r\n *         The codec string with old apple-style codecs replaced\r\n *\r\n * @private\r\n */\n\n\nvar mapLegacyAvcCodecs = function mapLegacyAvcCodecs(codecString) {\n  return codecString.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (match) {\n    return translateLegacyCodecs([match])[0];\n  });\n};\n/**\r\n * @typedef {Object} ParsedCodecInfo\r\n * @property {number} codecCount\r\n *           Number of codecs parsed\r\n * @property {string} [videoCodec]\r\n *           Parsed video codec (if found)\r\n * @property {string} [videoObjectTypeIndicator]\r\n *           Video object type indicator (if found)\r\n * @property {string|null} audioProfile\r\n *           Audio profile\r\n */\n\n/**\r\n * Parses a codec string to retrieve the number of codecs specified, the video codec and\r\n * object type indicator, and the audio profile.\r\n *\r\n * @param {string} [codecString]\r\n *        The codec string to parse\r\n * @return {ParsedCodecInfo}\r\n *         Parsed codec info\r\n */\n\n\nvar parseCodecs = function parseCodecs(codecString) {\n  if (codecString === void 0) {\n    codecString = '';\n  }\n\n  var codecs = codecString.split(',');\n  var result = {};\n  var unknown = [];\n  codecs.forEach(function (codec) {\n    codec = codec.trim();\n    var codecType;\n    mediaTypes.forEach(function (name) {\n      var match = regexs[name].exec(codec.toLowerCase());\n\n      if (!match || match.length <= 1) {\n        return;\n      }\n\n      codecType = name; // maintain codec case\n\n      var type = codec.substring(0, match[1].length);\n      var details = codec.replace(type, '');\n      result[name] = {\n        type: type,\n        details: details\n      };\n    });\n\n    if (!codecType) {\n      unknown.push(codec);\n    }\n  });\n\n  if (unknown.length) {\n    result.unknown = unknown;\n  }\n\n  return result;\n};\n/**\r\n * Returns a ParsedCodecInfo object for the default alternate audio playlist if there is\r\n * a default alternate audio playlist for the provided audio group.\r\n *\r\n * @param {Object} master\r\n *        The master playlist\r\n * @param {string} audioGroupId\r\n *        ID of the audio group for which to find the default codec info\r\n * @return {ParsedCodecInfo}\r\n *         Parsed codec info\r\n */\n\n\nvar codecsFromDefault = function codecsFromDefault(master, audioGroupId) {\n  if (!master.mediaGroups.AUDIO || !audioGroupId) {\n    return null;\n  }\n\n  var audioGroup = master.mediaGroups.AUDIO[audioGroupId];\n\n  if (!audioGroup) {\n    return null;\n  }\n\n  for (var name in audioGroup) {\n    var audioType = audioGroup[name];\n\n    if (audioType.default && audioType.playlists) {\n      // codec should be the same for all playlists within the audio type\n      return parseCodecs(audioType.playlists[0].attributes.CODECS);\n    }\n  }\n\n  return null;\n};\n\nvar isVideoCodec = function isVideoCodec(codec) {\n  if (codec === void 0) {\n    codec = '';\n  }\n\n  return regexs.video.test(codec.trim().toLowerCase());\n};\n\nvar isAudioCodec = function isAudioCodec(codec) {\n  if (codec === void 0) {\n    codec = '';\n  }\n\n  return regexs.audio.test(codec.trim().toLowerCase());\n};\n\nvar isTextCodec = function isTextCodec(codec) {\n  if (codec === void 0) {\n    codec = '';\n  }\n\n  return regexs.text.test(codec.trim().toLowerCase());\n};\n\nvar getMimeForCodec = function getMimeForCodec(codecString) {\n  if (!codecString || typeof codecString !== 'string') {\n    return;\n  }\n\n  var codecs = codecString.toLowerCase().split(',').map(function (c) {\n    return translateLegacyCodec(c.trim());\n  }); // default to video type\n\n  var type = 'video'; // only change to audio type if the only codec we have is\n  // audio\n\n  if (codecs.length === 1 && isAudioCodec(codecs[0])) {\n    type = 'audio';\n  } else if (codecs.length === 1 && isTextCodec(codecs[0])) {\n    // text uses application/<container> for now\n    type = 'application';\n  } // default the container to mp4\n\n\n  var container = 'mp4'; // every codec must be able to go into the container\n  // for that container to be the correct one\n\n  if (codecs.every(function (c) {\n    return regexs.mp4.test(c);\n  })) {\n    container = 'mp4';\n  } else if (codecs.every(function (c) {\n    return regexs.webm.test(c);\n  })) {\n    container = 'webm';\n  } else if (codecs.every(function (c) {\n    return regexs.ogg.test(c);\n  })) {\n    container = 'ogg';\n  }\n\n  return type + \"/\" + container + \";codecs=\\\"\" + codecString + \"\\\"\";\n};\n\nvar browserSupportsCodec = function browserSupportsCodec(codecString) {\n  if (codecString === void 0) {\n    codecString = '';\n  }\n\n  return window.MediaSource && window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;\n};\n\nvar muxerSupportsCodec = function muxerSupportsCodec(codecString) {\n  if (codecString === void 0) {\n    codecString = '';\n  }\n\n  return codecString.toLowerCase().split(',').every(function (codec) {\n    codec = codec.trim(); // any match is supported.\n\n    for (var i = 0; i < upperMediaTypes.length; i++) {\n      var type = upperMediaTypes[i];\n\n      if (regexs[\"muxer\" + type].test(codec)) {\n        return true;\n      }\n    }\n\n    return false;\n  });\n};\n\nvar DEFAULT_AUDIO_CODEC = 'mp4a.40.2';\nvar DEFAULT_VIDEO_CODEC = 'avc1.4d400d';\nexports.DEFAULT_AUDIO_CODEC = DEFAULT_AUDIO_CODEC;\nexports.DEFAULT_VIDEO_CODEC = DEFAULT_VIDEO_CODEC;\nexports.browserSupportsCodec = browserSupportsCodec;\nexports.codecsFromDefault = codecsFromDefault;\nexports.getMimeForCodec = getMimeForCodec;\nexports.isAudioCodec = isAudioCodec;\nexports.isTextCodec = isTextCodec;\nexports.isVideoCodec = isVideoCodec;\nexports.mapLegacyAvcCodecs = mapLegacyAvcCodecs;\nexports.muxerSupportsCodec = muxerSupportsCodec;\nexports.parseCodecs = parseCodecs;\nexports.translateLegacyCodec = translateLegacyCodec;\nexports.translateLegacyCodecs = translateLegacyCodecs;","map":{"version":3,"sources":["C:/Users/rodet/Documents/GitHub/but-project/node_modules/@videojs/vhs-utils/dist/codecs.js"],"names":["Object","defineProperty","exports","value","_interopDefault","ex","window","require","regexs","mp4","webm","ogg","video","audio","text","muxerVideo","muxerAudio","muxerText","mediaTypes","upperMediaTypes","translateLegacyCodec","codec","replace","orig","profile","avcLevel","profileHex","Number","toString","slice","avcLevelHex","translateLegacyCodecs","codecs","map","mapLegacyAvcCodecs","codecString","match","parseCodecs","split","result","unknown","forEach","trim","codecType","name","exec","toLowerCase","length","type","substring","details","push","codecsFromDefault","master","audioGroupId","mediaGroups","AUDIO","audioGroup","audioType","default","playlists","attributes","CODECS","isVideoCodec","test","isAudioCodec","isTextCodec","getMimeForCodec","c","container","every","browserSupportsCodec","MediaSource","isTypeSupported","muxerSupportsCodec","i","DEFAULT_AUDIO_CODEC","DEFAULT_VIDEO_CODEC"],"mappings":"AAAA;AACA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,SAASC,eAAT,CAA0BC,EAA1B,EAA8B;AAAE,SAAQA,EAAE,IAAK,OAAOA,EAAP,KAAc,QAArB,IAAkC,aAAaA,EAAhD,GAAsDA,EAAE,CAAC,SAAD,CAAxD,GAAsEA,EAA7E;AAAkF;;AAElH,IAAIC,MAAM,GAAGF,eAAe,CAACG,OAAO,CAAC,eAAD,CAAR,CAA5B;;AAEA,IAAIC,MAAM,GAAG;AACX;AACAC,EAAAA,GAAG,EAAE,mEAFM;AAGXC,EAAAA,IAAI,EAAE,+BAHK;AAIXC,EAAAA,GAAG,EAAE,qCAJM;AAKX;AACAC,EAAAA,KAAK,EAAE,qDANI;AAOXC,EAAAA,KAAK,EAAE,gDAPI;AAQXC,EAAAA,IAAI,EAAE,mBARK;AASX;AACAC,EAAAA,UAAU,EAAE,WAVD;AAWXC,EAAAA,UAAU,EAAE,SAXD;AAYX;AACA;AACA;AACAC,EAAAA,SAAS,EAAE;AAfA,CAAb;AAiBA,IAAIC,UAAU,GAAG,CAAC,OAAD,EAAU,OAAV,EAAmB,MAAnB,CAAjB;AACA,IAAIC,eAAe,GAAG,CAAC,OAAD,EAAU,OAAV,EAAmB,MAAnB,CAAtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,oBAAoB,GAAG,SAASA,oBAAT,CAA8BC,KAA9B,EAAqC;AAC9D,MAAI,CAACA,KAAL,EAAY;AACV,WAAOA,KAAP;AACD;;AAED,SAAOA,KAAK,CAACC,OAAN,CAAc,qBAAd,EAAqC,UAAUC,IAAV,EAAgBC,OAAhB,EAAyBC,QAAzB,EAAmC;AAC7E,QAAIC,UAAU,GAAG,CAAC,OAAOC,MAAM,CAACH,OAAD,CAAN,CAAgBI,QAAhB,CAAyB,EAAzB,CAAR,EAAsCC,KAAtC,CAA4C,CAAC,CAA7C,CAAjB;AACA,QAAIC,WAAW,GAAG,CAAC,OAAOH,MAAM,CAACF,QAAD,CAAN,CAAiBG,QAAjB,CAA0B,EAA1B,CAAR,EAAuCC,KAAvC,CAA6C,CAAC,CAA9C,CAAlB;AACA,WAAO,UAAUH,UAAV,GAAuB,IAAvB,GAA8BI,WAArC;AACD,GAJM,CAAP;AAKD,CAVD;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAIC,qBAAqB,GAAG,SAASA,qBAAT,CAA+BC,MAA/B,EAAuC;AACjE,SAAOA,MAAM,CAACC,GAAP,CAAWb,oBAAX,CAAP;AACD,CAFD;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAIc,kBAAkB,GAAG,SAASA,kBAAT,CAA4BC,WAA5B,EAAyC;AAChE,SAAOA,WAAW,CAACb,OAAZ,CAAoB,qBAApB,EAA2C,UAAUc,KAAV,EAAiB;AACjE,WAAOL,qBAAqB,CAAC,CAACK,KAAD,CAAD,CAArB,CAA+B,CAA/B,CAAP;AACD,GAFM,CAAP;AAGD,CAJD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAIC,WAAW,GAAG,SAASA,WAAT,CAAqBF,WAArB,EAAkC;AAClD,MAAIA,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAC1BA,IAAAA,WAAW,GAAG,EAAd;AACD;;AAED,MAAIH,MAAM,GAAGG,WAAW,CAACG,KAAZ,CAAkB,GAAlB,CAAb;AACA,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,OAAO,GAAG,EAAd;AACAR,EAAAA,MAAM,CAACS,OAAP,CAAe,UAAUpB,KAAV,EAAiB;AAC9BA,IAAAA,KAAK,GAAGA,KAAK,CAACqB,IAAN,EAAR;AACA,QAAIC,SAAJ;AACAzB,IAAAA,UAAU,CAACuB,OAAX,CAAmB,UAAUG,IAAV,EAAgB;AACjC,UAAIR,KAAK,GAAG5B,MAAM,CAACoC,IAAD,CAAN,CAAaC,IAAb,CAAkBxB,KAAK,CAACyB,WAAN,EAAlB,CAAZ;;AAEA,UAAI,CAACV,KAAD,IAAUA,KAAK,CAACW,MAAN,IAAgB,CAA9B,EAAiC;AAC/B;AACD;;AAEDJ,MAAAA,SAAS,GAAGC,IAAZ,CAPiC,CAOf;;AAElB,UAAII,IAAI,GAAG3B,KAAK,CAAC4B,SAAN,CAAgB,CAAhB,EAAmBb,KAAK,CAAC,CAAD,CAAL,CAASW,MAA5B,CAAX;AACA,UAAIG,OAAO,GAAG7B,KAAK,CAACC,OAAN,CAAc0B,IAAd,EAAoB,EAApB,CAAd;AACAT,MAAAA,MAAM,CAACK,IAAD,CAAN,GAAe;AACbI,QAAAA,IAAI,EAAEA,IADO;AAEbE,QAAAA,OAAO,EAAEA;AAFI,OAAf;AAID,KAfD;;AAiBA,QAAI,CAACP,SAAL,EAAgB;AACdH,MAAAA,OAAO,CAACW,IAAR,CAAa9B,KAAb;AACD;AACF,GAvBD;;AAyBA,MAAImB,OAAO,CAACO,MAAZ,EAAoB;AAClBR,IAAAA,MAAM,CAACC,OAAP,GAAiBA,OAAjB;AACD;;AAED,SAAOD,MAAP;AACD,CAtCD;AAuCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAIa,iBAAiB,GAAG,SAASA,iBAAT,CAA2BC,MAA3B,EAAmCC,YAAnC,EAAiD;AACvE,MAAI,CAACD,MAAM,CAACE,WAAP,CAAmBC,KAApB,IAA6B,CAACF,YAAlC,EAAgD;AAC9C,WAAO,IAAP;AACD;;AAED,MAAIG,UAAU,GAAGJ,MAAM,CAACE,WAAP,CAAmBC,KAAnB,CAAyBF,YAAzB,CAAjB;;AAEA,MAAI,CAACG,UAAL,EAAiB;AACf,WAAO,IAAP;AACD;;AAED,OAAK,IAAIb,IAAT,IAAiBa,UAAjB,EAA6B;AAC3B,QAAIC,SAAS,GAAGD,UAAU,CAACb,IAAD,CAA1B;;AAEA,QAAIc,SAAS,CAACC,OAAV,IAAqBD,SAAS,CAACE,SAAnC,EAA8C;AAC5C;AACA,aAAOvB,WAAW,CAACqB,SAAS,CAACE,SAAV,CAAoB,CAApB,EAAuBC,UAAvB,CAAkCC,MAAnC,CAAlB;AACD;AACF;;AAED,SAAO,IAAP;AACD,CArBD;;AAsBA,IAAIC,YAAY,GAAG,SAASA,YAAT,CAAsB1C,KAAtB,EAA6B;AAC9C,MAAIA,KAAK,KAAK,KAAK,CAAnB,EAAsB;AACpBA,IAAAA,KAAK,GAAG,EAAR;AACD;;AAED,SAAOb,MAAM,CAACI,KAAP,CAAaoD,IAAb,CAAkB3C,KAAK,CAACqB,IAAN,GAAaI,WAAb,EAAlB,CAAP;AACD,CAND;;AAOA,IAAImB,YAAY,GAAG,SAASA,YAAT,CAAsB5C,KAAtB,EAA6B;AAC9C,MAAIA,KAAK,KAAK,KAAK,CAAnB,EAAsB;AACpBA,IAAAA,KAAK,GAAG,EAAR;AACD;;AAED,SAAOb,MAAM,CAACK,KAAP,CAAamD,IAAb,CAAkB3C,KAAK,CAACqB,IAAN,GAAaI,WAAb,EAAlB,CAAP;AACD,CAND;;AAOA,IAAIoB,WAAW,GAAG,SAASA,WAAT,CAAqB7C,KAArB,EAA4B;AAC5C,MAAIA,KAAK,KAAK,KAAK,CAAnB,EAAsB;AACpBA,IAAAA,KAAK,GAAG,EAAR;AACD;;AAED,SAAOb,MAAM,CAACM,IAAP,CAAYkD,IAAZ,CAAiB3C,KAAK,CAACqB,IAAN,GAAaI,WAAb,EAAjB,CAAP;AACD,CAND;;AAOA,IAAIqB,eAAe,GAAG,SAASA,eAAT,CAAyBhC,WAAzB,EAAsC;AAC1D,MAAI,CAACA,WAAD,IAAgB,OAAOA,WAAP,KAAuB,QAA3C,EAAqD;AACnD;AACD;;AAED,MAAIH,MAAM,GAAGG,WAAW,CAACW,WAAZ,GAA0BR,KAA1B,CAAgC,GAAhC,EAAqCL,GAArC,CAAyC,UAAUmC,CAAV,EAAa;AACjE,WAAOhD,oBAAoB,CAACgD,CAAC,CAAC1B,IAAF,EAAD,CAA3B;AACD,GAFY,CAAb,CAL0D,CAOtD;;AAEJ,MAAIM,IAAI,GAAG,OAAX,CAT0D,CAStC;AACpB;;AAEA,MAAIhB,MAAM,CAACe,MAAP,KAAkB,CAAlB,IAAuBkB,YAAY,CAACjC,MAAM,CAAC,CAAD,CAAP,CAAvC,EAAoD;AAClDgB,IAAAA,IAAI,GAAG,OAAP;AACD,GAFD,MAEO,IAAIhB,MAAM,CAACe,MAAP,KAAkB,CAAlB,IAAuBmB,WAAW,CAAClC,MAAM,CAAC,CAAD,CAAP,CAAtC,EAAmD;AACxD;AACAgB,IAAAA,IAAI,GAAG,aAAP;AACD,GAjByD,CAiBxD;;;AAGF,MAAIqB,SAAS,GAAG,KAAhB,CApB0D,CAoBnC;AACvB;;AAEA,MAAIrC,MAAM,CAACsC,KAAP,CAAa,UAAUF,CAAV,EAAa;AAC5B,WAAO5D,MAAM,CAACC,GAAP,CAAWuD,IAAX,CAAgBI,CAAhB,CAAP;AACD,GAFG,CAAJ,EAEI;AACFC,IAAAA,SAAS,GAAG,KAAZ;AACD,GAJD,MAIO,IAAIrC,MAAM,CAACsC,KAAP,CAAa,UAAUF,CAAV,EAAa;AACnC,WAAO5D,MAAM,CAACE,IAAP,CAAYsD,IAAZ,CAAiBI,CAAjB,CAAP;AACD,GAFU,CAAJ,EAEH;AACFC,IAAAA,SAAS,GAAG,MAAZ;AACD,GAJM,MAIA,IAAIrC,MAAM,CAACsC,KAAP,CAAa,UAAUF,CAAV,EAAa;AACnC,WAAO5D,MAAM,CAACG,GAAP,CAAWqD,IAAX,CAAgBI,CAAhB,CAAP;AACD,GAFU,CAAJ,EAEH;AACFC,IAAAA,SAAS,GAAG,KAAZ;AACD;;AAED,SAAOrB,IAAI,GAAG,GAAP,GAAaqB,SAAb,GAAyB,YAAzB,GAAwClC,WAAxC,GAAsD,IAA7D;AACD,CAtCD;;AAuCA,IAAIoC,oBAAoB,GAAG,SAASA,oBAAT,CAA8BpC,WAA9B,EAA2C;AACpE,MAAIA,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAC1BA,IAAAA,WAAW,GAAG,EAAd;AACD;;AAED,SAAO7B,MAAM,CAACkE,WAAP,IAAsBlE,MAAM,CAACkE,WAAP,CAAmBC,eAAzC,IAA4DnE,MAAM,CAACkE,WAAP,CAAmBC,eAAnB,CAAmCN,eAAe,CAAChC,WAAD,CAAlD,CAA5D,IAAgI,KAAvI;AACD,CAND;;AAOA,IAAIuC,kBAAkB,GAAG,SAASA,kBAAT,CAA4BvC,WAA5B,EAAyC;AAChE,MAAIA,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAC1BA,IAAAA,WAAW,GAAG,EAAd;AACD;;AAED,SAAOA,WAAW,CAACW,WAAZ,GAA0BR,KAA1B,CAAgC,GAAhC,EAAqCgC,KAArC,CAA2C,UAAUjD,KAAV,EAAiB;AACjEA,IAAAA,KAAK,GAAGA,KAAK,CAACqB,IAAN,EAAR,CADiE,CAC3C;;AAEtB,SAAK,IAAIiC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGxD,eAAe,CAAC4B,MAApC,EAA4C4B,CAAC,EAA7C,EAAiD;AAC/C,UAAI3B,IAAI,GAAG7B,eAAe,CAACwD,CAAD,CAA1B;;AAEA,UAAInE,MAAM,CAAC,UAAUwC,IAAX,CAAN,CAAuBgB,IAAvB,CAA4B3C,KAA5B,CAAJ,EAAwC;AACtC,eAAO,IAAP;AACD;AACF;;AAED,WAAO,KAAP;AACD,GAZM,CAAP;AAaD,CAlBD;;AAmBA,IAAIuD,mBAAmB,GAAG,WAA1B;AACA,IAAIC,mBAAmB,GAAG,aAA1B;AAEA3E,OAAO,CAAC0E,mBAAR,GAA8BA,mBAA9B;AACA1E,OAAO,CAAC2E,mBAAR,GAA8BA,mBAA9B;AACA3E,OAAO,CAACqE,oBAAR,GAA+BA,oBAA/B;AACArE,OAAO,CAACkD,iBAAR,GAA4BA,iBAA5B;AACAlD,OAAO,CAACiE,eAAR,GAA0BA,eAA1B;AACAjE,OAAO,CAAC+D,YAAR,GAAuBA,YAAvB;AACA/D,OAAO,CAACgE,WAAR,GAAsBA,WAAtB;AACAhE,OAAO,CAAC6D,YAAR,GAAuBA,YAAvB;AACA7D,OAAO,CAACgC,kBAAR,GAA6BA,kBAA7B;AACAhC,OAAO,CAACwE,kBAAR,GAA6BA,kBAA7B;AACAxE,OAAO,CAACmC,WAAR,GAAsBA,WAAtB;AACAnC,OAAO,CAACkB,oBAAR,GAA+BA,oBAA/B;AACAlB,OAAO,CAAC6B,qBAAR,GAAgCA,qBAAhC","sourcesContent":["/*! @name @videojs/vhs-utils @version 2.3.0 @license MIT */\r\n'use strict';\r\n\r\nObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\r\n\r\nvar window = _interopDefault(require('global/window'));\r\n\r\nvar regexs = {\r\n  // to determine mime types\r\n  mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,\r\n  webm: /^(vp0?[89]|av0?1|opus|vorbis)/,\r\n  ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,\r\n  // to determine if a codec is audio or video\r\n  video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,\r\n  audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3)/,\r\n  text: /^(stpp.ttml.im1t)/,\r\n  // mux.js support regex\r\n  muxerVideo: /^(avc0?1)/,\r\n  muxerAudio: /^(mp4a)/,\r\n  // match nothing as muxer does not support text right now.\r\n  // there cannot never be a character before the start of a string\r\n  // so this matches nothing.\r\n  muxerText: /a^/\r\n};\r\nvar mediaTypes = ['video', 'audio', 'text'];\r\nvar upperMediaTypes = ['Video', 'Audio', 'Text'];\r\n/**\r\n * Replace the old apple-style `avc1.<dd>.<dd>` codec string with the standard\r\n * `avc1.<hhhhhh>`\r\n *\r\n * @param {string} codec\r\n *        Codec string to translate\r\n * @return {string}\r\n *         The translated codec string\r\n */\r\n\r\nvar translateLegacyCodec = function translateLegacyCodec(codec) {\r\n  if (!codec) {\r\n    return codec;\r\n  }\r\n\r\n  return codec.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (orig, profile, avcLevel) {\r\n    var profileHex = ('00' + Number(profile).toString(16)).slice(-2);\r\n    var avcLevelHex = ('00' + Number(avcLevel).toString(16)).slice(-2);\r\n    return 'avc1.' + profileHex + '00' + avcLevelHex;\r\n  });\r\n};\r\n/**\r\n * Replace the old apple-style `avc1.<dd>.<dd>` codec strings with the standard\r\n * `avc1.<hhhhhh>`\r\n *\r\n * @param {string[]} codecs\r\n *        An array of codec strings to translate\r\n * @return {string[]}\r\n *         The translated array of codec strings\r\n */\r\n\r\nvar translateLegacyCodecs = function translateLegacyCodecs(codecs) {\r\n  return codecs.map(translateLegacyCodec);\r\n};\r\n/**\r\n * Replace codecs in the codec string with the old apple-style `avc1.<dd>.<dd>` to the\r\n * standard `avc1.<hhhhhh>`.\r\n *\r\n * @param {string} codecString\r\n *        The codec string\r\n * @return {string}\r\n *         The codec string with old apple-style codecs replaced\r\n *\r\n * @private\r\n */\r\n\r\nvar mapLegacyAvcCodecs = function mapLegacyAvcCodecs(codecString) {\r\n  return codecString.replace(/avc1\\.(\\d+)\\.(\\d+)/i, function (match) {\r\n    return translateLegacyCodecs([match])[0];\r\n  });\r\n};\r\n/**\r\n * @typedef {Object} ParsedCodecInfo\r\n * @property {number} codecCount\r\n *           Number of codecs parsed\r\n * @property {string} [videoCodec]\r\n *           Parsed video codec (if found)\r\n * @property {string} [videoObjectTypeIndicator]\r\n *           Video object type indicator (if found)\r\n * @property {string|null} audioProfile\r\n *           Audio profile\r\n */\r\n\r\n/**\r\n * Parses a codec string to retrieve the number of codecs specified, the video codec and\r\n * object type indicator, and the audio profile.\r\n *\r\n * @param {string} [codecString]\r\n *        The codec string to parse\r\n * @return {ParsedCodecInfo}\r\n *         Parsed codec info\r\n */\r\n\r\nvar parseCodecs = function parseCodecs(codecString) {\r\n  if (codecString === void 0) {\r\n    codecString = '';\r\n  }\r\n\r\n  var codecs = codecString.split(',');\r\n  var result = {};\r\n  var unknown = [];\r\n  codecs.forEach(function (codec) {\r\n    codec = codec.trim();\r\n    var codecType;\r\n    mediaTypes.forEach(function (name) {\r\n      var match = regexs[name].exec(codec.toLowerCase());\r\n\r\n      if (!match || match.length <= 1) {\r\n        return;\r\n      }\r\n\r\n      codecType = name; // maintain codec case\r\n\r\n      var type = codec.substring(0, match[1].length);\r\n      var details = codec.replace(type, '');\r\n      result[name] = {\r\n        type: type,\r\n        details: details\r\n      };\r\n    });\r\n\r\n    if (!codecType) {\r\n      unknown.push(codec);\r\n    }\r\n  });\r\n\r\n  if (unknown.length) {\r\n    result.unknown = unknown;\r\n  }\r\n\r\n  return result;\r\n};\r\n/**\r\n * Returns a ParsedCodecInfo object for the default alternate audio playlist if there is\r\n * a default alternate audio playlist for the provided audio group.\r\n *\r\n * @param {Object} master\r\n *        The master playlist\r\n * @param {string} audioGroupId\r\n *        ID of the audio group for which to find the default codec info\r\n * @return {ParsedCodecInfo}\r\n *         Parsed codec info\r\n */\r\n\r\nvar codecsFromDefault = function codecsFromDefault(master, audioGroupId) {\r\n  if (!master.mediaGroups.AUDIO || !audioGroupId) {\r\n    return null;\r\n  }\r\n\r\n  var audioGroup = master.mediaGroups.AUDIO[audioGroupId];\r\n\r\n  if (!audioGroup) {\r\n    return null;\r\n  }\r\n\r\n  for (var name in audioGroup) {\r\n    var audioType = audioGroup[name];\r\n\r\n    if (audioType.default && audioType.playlists) {\r\n      // codec should be the same for all playlists within the audio type\r\n      return parseCodecs(audioType.playlists[0].attributes.CODECS);\r\n    }\r\n  }\r\n\r\n  return null;\r\n};\r\nvar isVideoCodec = function isVideoCodec(codec) {\r\n  if (codec === void 0) {\r\n    codec = '';\r\n  }\r\n\r\n  return regexs.video.test(codec.trim().toLowerCase());\r\n};\r\nvar isAudioCodec = function isAudioCodec(codec) {\r\n  if (codec === void 0) {\r\n    codec = '';\r\n  }\r\n\r\n  return regexs.audio.test(codec.trim().toLowerCase());\r\n};\r\nvar isTextCodec = function isTextCodec(codec) {\r\n  if (codec === void 0) {\r\n    codec = '';\r\n  }\r\n\r\n  return regexs.text.test(codec.trim().toLowerCase());\r\n};\r\nvar getMimeForCodec = function getMimeForCodec(codecString) {\r\n  if (!codecString || typeof codecString !== 'string') {\r\n    return;\r\n  }\r\n\r\n  var codecs = codecString.toLowerCase().split(',').map(function (c) {\r\n    return translateLegacyCodec(c.trim());\r\n  }); // default to video type\r\n\r\n  var type = 'video'; // only change to audio type if the only codec we have is\r\n  // audio\r\n\r\n  if (codecs.length === 1 && isAudioCodec(codecs[0])) {\r\n    type = 'audio';\r\n  } else if (codecs.length === 1 && isTextCodec(codecs[0])) {\r\n    // text uses application/<container> for now\r\n    type = 'application';\r\n  } // default the container to mp4\r\n\r\n\r\n  var container = 'mp4'; // every codec must be able to go into the container\r\n  // for that container to be the correct one\r\n\r\n  if (codecs.every(function (c) {\r\n    return regexs.mp4.test(c);\r\n  })) {\r\n    container = 'mp4';\r\n  } else if (codecs.every(function (c) {\r\n    return regexs.webm.test(c);\r\n  })) {\r\n    container = 'webm';\r\n  } else if (codecs.every(function (c) {\r\n    return regexs.ogg.test(c);\r\n  })) {\r\n    container = 'ogg';\r\n  }\r\n\r\n  return type + \"/\" + container + \";codecs=\\\"\" + codecString + \"\\\"\";\r\n};\r\nvar browserSupportsCodec = function browserSupportsCodec(codecString) {\r\n  if (codecString === void 0) {\r\n    codecString = '';\r\n  }\r\n\r\n  return window.MediaSource && window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;\r\n};\r\nvar muxerSupportsCodec = function muxerSupportsCodec(codecString) {\r\n  if (codecString === void 0) {\r\n    codecString = '';\r\n  }\r\n\r\n  return codecString.toLowerCase().split(',').every(function (codec) {\r\n    codec = codec.trim(); // any match is supported.\r\n\r\n    for (var i = 0; i < upperMediaTypes.length; i++) {\r\n      var type = upperMediaTypes[i];\r\n\r\n      if (regexs[\"muxer\" + type].test(codec)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  });\r\n};\r\nvar DEFAULT_AUDIO_CODEC = 'mp4a.40.2';\r\nvar DEFAULT_VIDEO_CODEC = 'avc1.4d400d';\r\n\r\nexports.DEFAULT_AUDIO_CODEC = DEFAULT_AUDIO_CODEC;\r\nexports.DEFAULT_VIDEO_CODEC = DEFAULT_VIDEO_CODEC;\r\nexports.browserSupportsCodec = browserSupportsCodec;\r\nexports.codecsFromDefault = codecsFromDefault;\r\nexports.getMimeForCodec = getMimeForCodec;\r\nexports.isAudioCodec = isAudioCodec;\r\nexports.isTextCodec = isTextCodec;\r\nexports.isVideoCodec = isVideoCodec;\r\nexports.mapLegacyAvcCodecs = mapLegacyAvcCodecs;\r\nexports.muxerSupportsCodec = muxerSupportsCodec;\r\nexports.parseCodecs = parseCodecs;\r\nexports.translateLegacyCodec = translateLegacyCodec;\r\nexports.translateLegacyCodecs = translateLegacyCodecs;\r\n"]},"metadata":{},"sourceType":"script"}
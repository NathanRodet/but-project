{"ast":null,"code":"/*! @name @videojs/vhs-utils @version 2.3.0 @license MIT */\n'use strict';\n/**\r\n * @file stream.js\r\n */\n\n/**\r\n * A lightweight readable stream implemention that handles event dispatching.\r\n *\r\n * @class Stream\r\n */\n\nvar Stream = /*#__PURE__*/function () {\n  function Stream() {\n    this.listeners = {};\n  }\n  /**\r\n   * Add a listener for a specified event type.\r\n   *\r\n   * @param {string} type the event name\r\n   * @param {Function} listener the callback to be invoked when an event of\r\n   * the specified type occurs\r\n   */\n\n\n  var _proto = Stream.prototype;\n\n  _proto.on = function on(type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(listener);\n  }\n  /**\r\n   * Remove a listener for a specified event type.\r\n   *\r\n   * @param {string} type the event name\r\n   * @param {Function} listener  a function previously registered for this\r\n   * type of event through `on`\r\n   * @return {boolean} if we could turn it off or not\r\n   */\n  ;\n\n  _proto.off = function off(type, listener) {\n    if (!this.listeners[type]) {\n      return false;\n    }\n\n    var index = this.listeners[type].indexOf(listener); // TODO: which is better?\n    // In Video.js we slice listener functions\n    // on trigger so that it does not mess up the order\n    // while we loop through.\n    //\n    // Here we slice on off so that the loop in trigger\n    // can continue using it's old reference to loop without\n    // messing up the order.\n\n    this.listeners[type] = this.listeners[type].slice(0);\n    this.listeners[type].splice(index, 1);\n    return index > -1;\n  }\n  /**\r\n   * Trigger an event of the specified type on this stream. Any additional\r\n   * arguments to this function are passed as parameters to event listeners.\r\n   *\r\n   * @param {string} type the event name\r\n   */\n  ;\n\n  _proto.trigger = function trigger(type) {\n    var callbacks = this.listeners[type];\n\n    if (!callbacks) {\n      return;\n    } // Slicing the arguments on every invocation of this method\n    // can add a significant amount of overhead. Avoid the\n    // intermediate object creation for the common case of a\n    // single callback argument\n\n\n    if (arguments.length === 2) {\n      var length = callbacks.length;\n\n      for (var i = 0; i < length; ++i) {\n        callbacks[i].call(this, arguments[1]);\n      }\n    } else {\n      var args = Array.prototype.slice.call(arguments, 1);\n      var _length = callbacks.length;\n\n      for (var _i = 0; _i < _length; ++_i) {\n        callbacks[_i].apply(this, args);\n      }\n    }\n  }\n  /**\r\n   * Destroys the stream and cleans up.\r\n   */\n  ;\n\n  _proto.dispose = function dispose() {\n    this.listeners = {};\n  }\n  /**\r\n   * Forwards all `data` events on this stream to the destination stream. The\r\n   * destination stream should provide a method `push` to receive the data\r\n   * events as they arrive.\r\n   *\r\n   * @param {Stream} destination the stream that will receive all `data` events\r\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\r\n   */\n  ;\n\n  _proto.pipe = function pipe(destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n  };\n\n  return Stream;\n}();\n\nmodule.exports = Stream;","map":{"version":3,"sources":["C:/Users/franc/Documents/GitHub/but-project/node_modules/@videojs/vhs-utils/dist/stream.js"],"names":["Stream","listeners","_proto","prototype","on","type","listener","push","off","index","indexOf","slice","splice","trigger","callbacks","arguments","length","i","call","args","Array","_length","_i","apply","dispose","pipe","destination","data","module","exports"],"mappings":"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","sourcesContent":["/*! @name @videojs/vhs-utils @version 2.3.0 @license MIT */\r\n'use strict';\r\n\r\n/**\r\n * @file stream.js\r\n */\r\n\r\n/**\r\n * A lightweight readable stream implemention that handles event dispatching.\r\n *\r\n * @class Stream\r\n */\r\nvar Stream =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function Stream() {\r\n    this.listeners = {};\r\n  }\r\n  /**\r\n   * Add a listener for a specified event type.\r\n   *\r\n   * @param {string} type the event name\r\n   * @param {Function} listener the callback to be invoked when an event of\r\n   * the specified type occurs\r\n   */\r\n\r\n\r\n  var _proto = Stream.prototype;\r\n\r\n  _proto.on = function on(type, listener) {\r\n    if (!this.listeners[type]) {\r\n      this.listeners[type] = [];\r\n    }\r\n\r\n    this.listeners[type].push(listener);\r\n  }\r\n  /**\r\n   * Remove a listener for a specified event type.\r\n   *\r\n   * @param {string} type the event name\r\n   * @param {Function} listener  a function previously registered for this\r\n   * type of event through `on`\r\n   * @return {boolean} if we could turn it off or not\r\n   */\r\n  ;\r\n\r\n  _proto.off = function off(type, listener) {\r\n    if (!this.listeners[type]) {\r\n      return false;\r\n    }\r\n\r\n    var index = this.listeners[type].indexOf(listener); // TODO: which is better?\r\n    // In Video.js we slice listener functions\r\n    // on trigger so that it does not mess up the order\r\n    // while we loop through.\r\n    //\r\n    // Here we slice on off so that the loop in trigger\r\n    // can continue using it's old reference to loop without\r\n    // messing up the order.\r\n\r\n    this.listeners[type] = this.listeners[type].slice(0);\r\n    this.listeners[type].splice(index, 1);\r\n    return index > -1;\r\n  }\r\n  /**\r\n   * Trigger an event of the specified type on this stream. Any additional\r\n   * arguments to this function are passed as parameters to event listeners.\r\n   *\r\n   * @param {string} type the event name\r\n   */\r\n  ;\r\n\r\n  _proto.trigger = function trigger(type) {\r\n    var callbacks = this.listeners[type];\r\n\r\n    if (!callbacks) {\r\n      return;\r\n    } // Slicing the arguments on every invocation of this method\r\n    // can add a significant amount of overhead. Avoid the\r\n    // intermediate object creation for the common case of a\r\n    // single callback argument\r\n\r\n\r\n    if (arguments.length === 2) {\r\n      var length = callbacks.length;\r\n\r\n      for (var i = 0; i < length; ++i) {\r\n        callbacks[i].call(this, arguments[1]);\r\n      }\r\n    } else {\r\n      var args = Array.prototype.slice.call(arguments, 1);\r\n      var _length = callbacks.length;\r\n\r\n      for (var _i = 0; _i < _length; ++_i) {\r\n        callbacks[_i].apply(this, args);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Destroys the stream and cleans up.\r\n   */\r\n  ;\r\n\r\n  _proto.dispose = function dispose() {\r\n    this.listeners = {};\r\n  }\r\n  /**\r\n   * Forwards all `data` events on this stream to the destination stream. The\r\n   * destination stream should provide a method `push` to receive the data\r\n   * events as they arrive.\r\n   *\r\n   * @param {Stream} destination the stream that will receive all `data` events\r\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\r\n   */\r\n  ;\r\n\r\n  _proto.pipe = function pipe(destination) {\r\n    this.on('data', function (data) {\r\n      destination.push(data);\r\n    });\r\n  };\r\n\r\n  return Stream;\r\n}();\r\n\r\nmodule.exports = Stream;\r\n"]},"metadata":{},"sourceType":"script"}
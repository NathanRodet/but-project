{"ast":null,"code":"/**\r\n * mux.js\r\n *\r\n * Copyright (c) Brightcove\r\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n *\r\n * Parse mpeg2 transport stream packets to extract basic timing information\r\n */\n'use strict';\n\nvar StreamTypes = require('../m2ts/stream-types.js');\n\nvar handleRollover = require('../m2ts/timestamp-rollover-stream.js').handleRollover;\n\nvar probe = {};\nprobe.ts = require('../m2ts/probe.js');\nprobe.aac = require('../aac/utils.js');\n\nvar ONE_SECOND_IN_TS = require('../utils/clock').ONE_SECOND_IN_TS;\n\nvar MP2T_PACKET_LENGTH = 188,\n    // bytes\nSYNC_BYTE = 0x47;\n/**\r\n * walks through segment data looking for pat and pmt packets to parse out\r\n * program map table information\r\n */\n\nvar parsePsi_ = function (bytes, pmt) {\n  var startIndex = 0,\n      endIndex = MP2T_PACKET_LENGTH,\n      packet,\n      type;\n\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pat':\n          if (!pmt.pid) {\n            pmt.pid = probe.ts.parsePat(packet);\n          }\n\n          break;\n\n        case 'pmt':\n          if (!pmt.table) {\n            pmt.table = probe.ts.parsePmt(packet);\n          }\n\n          break;\n\n        default:\n          break;\n      } // Found the pat and pmt, we can stop walking the segment\n\n\n      if (pmt.pid && pmt.table) {\n        return;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    } // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n\n\n    startIndex++;\n    endIndex++;\n  }\n};\n/**\r\n * walks through the segment data from the start and end to get timing information\r\n * for the first and last audio pes packets\r\n */\n\n\nvar parseAudioPes_ = function (bytes, pmt, result) {\n  var startIndex = 0,\n      endIndex = MP2T_PACKET_LENGTH,\n      packet,\n      type,\n      pesType,\n      pusi,\n      parsed;\n  var endLoop = false; // Start walking from start of segment to get first audio packet\n\n  while (endIndex <= bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    } // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n\n\n    startIndex++;\n    endIndex++;\n  } // Start walking from end of segment to get last audio packet\n\n\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    } // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n\n\n    startIndex--;\n    endIndex--;\n  }\n};\n/**\r\n * walks through the segment data from the start and end to get timing information\r\n * for the first and last video pes packets as well as timing information for the first\r\n * key frame.\r\n */\n\n\nvar parseVideoPes_ = function (bytes, pmt, result) {\n  var startIndex = 0,\n      endIndex = MP2T_PACKET_LENGTH,\n      packet,\n      type,\n      pesType,\n      pusi,\n      parsed,\n      frame,\n      i,\n      pes;\n  var endLoop = false;\n  var currentFrame = {\n    data: [],\n    size: 0\n  }; // Start walking from start of segment to get first video packet\n\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n          if (pesType === 'video') {\n            if (pusi && !endLoop) {\n              parsed = probe.ts.parsePesTime(packet);\n\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n            }\n\n            if (!result.firstKeyFrame) {\n              if (pusi) {\n                if (currentFrame.size !== 0) {\n                  frame = new Uint8Array(currentFrame.size);\n                  i = 0;\n\n                  while (currentFrame.data.length) {\n                    pes = currentFrame.data.shift();\n                    frame.set(pes, i);\n                    i += pes.byteLength;\n                  }\n\n                  if (probe.ts.videoPacketContainsKeyFrame(frame)) {\n                    var firstKeyFrame = probe.ts.parsePesTime(frame); // PTS/DTS may not be available. Simply *not* setting\n                    // the keyframe seems to work fine with HLS playback\n                    // and definitely preferable to a crash with TypeError...\n\n                    if (firstKeyFrame) {\n                      result.firstKeyFrame = firstKeyFrame;\n                      result.firstKeyFrame.type = 'video';\n                    } else {\n                      // eslint-disable-next-line\n                      console.warn('Failed to extract PTS/DTS from PES at first keyframe. ' + 'This could be an unusual TS segment, or else mux.js did not ' + 'parse your TS segment correctly. If you know your TS ' + 'segments do contain PTS/DTS on keyframes please file a bug ' + 'report! You can try ffprobe to double check for yourself.');\n                    }\n                  }\n\n                  currentFrame.size = 0;\n                }\n              }\n\n              currentFrame.data.push(packet);\n              currentFrame.size += packet.byteLength;\n            }\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      if (endLoop && result.firstKeyFrame) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    } // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n\n\n    startIndex++;\n    endIndex++;\n  } // Start walking from end of segment to get last video packet\n\n\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n          if (pesType === 'video' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n\n            if (parsed) {\n              parsed.type = 'video';\n              result.video.push(parsed);\n              endLoop = true;\n            }\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    } // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n\n\n    startIndex--;\n    endIndex--;\n  }\n};\n/**\r\n * Adjusts the timestamp information for the segment to account for\r\n * rollover and convert to seconds based on pes packet timescale (90khz clock)\r\n */\n\n\nvar adjustTimestamp_ = function (segmentInfo, baseTimestamp) {\n  if (segmentInfo.audio && segmentInfo.audio.length) {\n    var audioBaseTimestamp = baseTimestamp;\n\n    if (typeof audioBaseTimestamp === 'undefined') {\n      audioBaseTimestamp = segmentInfo.audio[0].dts;\n    }\n\n    segmentInfo.audio.forEach(function (info) {\n      info.dts = handleRollover(info.dts, audioBaseTimestamp);\n      info.pts = handleRollover(info.pts, audioBaseTimestamp); // time in seconds\n\n      info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n      info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n    });\n  }\n\n  if (segmentInfo.video && segmentInfo.video.length) {\n    var videoBaseTimestamp = baseTimestamp;\n\n    if (typeof videoBaseTimestamp === 'undefined') {\n      videoBaseTimestamp = segmentInfo.video[0].dts;\n    }\n\n    segmentInfo.video.forEach(function (info) {\n      info.dts = handleRollover(info.dts, videoBaseTimestamp);\n      info.pts = handleRollover(info.pts, videoBaseTimestamp); // time in seconds\n\n      info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n      info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n    });\n\n    if (segmentInfo.firstKeyFrame) {\n      var frame = segmentInfo.firstKeyFrame;\n      frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\n      frame.pts = handleRollover(frame.pts, videoBaseTimestamp); // time in seconds\n\n      frame.dtsTime = frame.dts / ONE_SECOND_IN_TS;\n      frame.ptsTime = frame.dts / ONE_SECOND_IN_TS;\n    }\n  }\n};\n/**\r\n * inspects the aac data stream for start and end time information\r\n */\n\n\nvar inspectAac_ = function (bytes) {\n  var endLoop = false,\n      audioCount = 0,\n      sampleRate = null,\n      timestamp = null,\n      frameSize = 0,\n      byteIndex = 0,\n      packet;\n\n  while (bytes.length - byteIndex >= 3) {\n    var type = probe.aac.parseType(bytes, byteIndex);\n\n    switch (type) {\n      case 'timed-metadata':\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (bytes.length - byteIndex < 10) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseId3TagSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n\n        if (timestamp === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          timestamp = probe.aac.parseAacTimestamp(packet);\n        }\n\n        byteIndex += frameSize;\n        break;\n\n      case 'audio':\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (bytes.length - byteIndex < 7) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseAdtsSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n\n        if (sampleRate === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          sampleRate = probe.aac.parseSampleRate(packet);\n        }\n\n        audioCount++;\n        byteIndex += frameSize;\n        break;\n\n      default:\n        byteIndex++;\n        break;\n    }\n\n    if (endLoop) {\n      return null;\n    }\n  }\n\n  if (sampleRate === null || timestamp === null) {\n    return null;\n  }\n\n  var audioTimescale = ONE_SECOND_IN_TS / sampleRate;\n  var result = {\n    audio: [{\n      type: 'audio',\n      dts: timestamp,\n      pts: timestamp\n    }, {\n      type: 'audio',\n      dts: timestamp + audioCount * 1024 * audioTimescale,\n      pts: timestamp + audioCount * 1024 * audioTimescale\n    }]\n  };\n  return result;\n};\n/**\r\n * inspects the transport stream segment data for start and end time information\r\n * of the audio and video tracks (when present) as well as the first key frame's\r\n * start time.\r\n */\n\n\nvar inspectTs_ = function (bytes) {\n  var pmt = {\n    pid: null,\n    table: null\n  };\n  var result = {};\n  parsePsi_(bytes, pmt);\n\n  for (var pid in pmt.table) {\n    if (pmt.table.hasOwnProperty(pid)) {\n      var type = pmt.table[pid];\n\n      switch (type) {\n        case StreamTypes.H264_STREAM_TYPE:\n          result.video = [];\n          parseVideoPes_(bytes, pmt, result);\n\n          if (result.video.length === 0) {\n            delete result.video;\n          }\n\n          break;\n\n        case StreamTypes.ADTS_STREAM_TYPE:\n          result.audio = [];\n          parseAudioPes_(bytes, pmt, result);\n\n          if (result.audio.length === 0) {\n            delete result.audio;\n          }\n\n          break;\n\n        default:\n          break;\n      }\n    }\n  }\n\n  return result;\n};\n/**\r\n * Inspects segment byte data and returns an object with start and end timing information\r\n *\r\n * @param {Uint8Array} bytes The segment byte data\r\n * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\r\n *  timestamps for rollover. This value must be in 90khz clock.\r\n * @return {Object} Object containing start and end frame timing info of segment.\r\n */\n\n\nvar inspect = function (bytes, baseTimestamp) {\n  var isAacData = probe.aac.isLikelyAacData(bytes);\n  var result;\n\n  if (isAacData) {\n    result = inspectAac_(bytes);\n  } else {\n    result = inspectTs_(bytes);\n  }\n\n  if (!result || !result.audio && !result.video) {\n    return null;\n  }\n\n  adjustTimestamp_(result, baseTimestamp);\n  return result;\n};\n\nmodule.exports = {\n  inspect: inspect,\n  parseAudioPes_: parseAudioPes_\n};","map":{"version":3,"sources":["C:/Users/rodet/Documents/GitHub/but-project/node_modules/mux.js/lib/tools/ts-inspector.js"],"names":["StreamTypes","require","handleRollover","probe","ts","aac","ONE_SECOND_IN_TS","MP2T_PACKET_LENGTH","SYNC_BYTE","parsePsi_","bytes","pmt","startIndex","endIndex","packet","type","byteLength","subarray","parseType","pid","parsePat","table","parsePmt","parseAudioPes_","result","pesType","pusi","parsed","endLoop","parsePesType","parsePayloadUnitStartIndicator","parsePesTime","audio","push","parseVideoPes_","frame","i","pes","currentFrame","data","size","video","firstKeyFrame","Uint8Array","length","shift","set","videoPacketContainsKeyFrame","console","warn","adjustTimestamp_","segmentInfo","baseTimestamp","audioBaseTimestamp","dts","forEach","info","pts","dtsTime","ptsTime","videoBaseTimestamp","inspectAac_","audioCount","sampleRate","timestamp","frameSize","byteIndex","parseId3TagSize","parseAacTimestamp","parseAdtsSize","parseSampleRate","audioTimescale","inspectTs_","hasOwnProperty","H264_STREAM_TYPE","ADTS_STREAM_TYPE","inspect","isAacData","isLikelyAacData","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * mux.js\r\n *\r\n * Copyright (c) Brightcove\r\n * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\r\n *\r\n * Parse mpeg2 transport stream packets to extract basic timing information\r\n */\r\n'use strict';\r\n\r\nvar StreamTypes = require('../m2ts/stream-types.js');\r\nvar handleRollover = require('../m2ts/timestamp-rollover-stream.js').handleRollover;\r\nvar probe = {};\r\nprobe.ts = require('../m2ts/probe.js');\r\nprobe.aac = require('../aac/utils.js');\r\nvar ONE_SECOND_IN_TS = require('../utils/clock').ONE_SECOND_IN_TS;\r\n\r\nvar\r\n  MP2T_PACKET_LENGTH = 188, // bytes\r\n  SYNC_BYTE = 0x47;\r\n\r\n/**\r\n * walks through segment data looking for pat and pmt packets to parse out\r\n * program map table information\r\n */\r\nvar parsePsi_ = function(bytes, pmt) {\r\n  var\r\n    startIndex = 0,\r\n    endIndex = MP2T_PACKET_LENGTH,\r\n    packet, type;\r\n\r\n  while (endIndex < bytes.byteLength) {\r\n    // Look for a pair of start and end sync bytes in the data..\r\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\r\n      // We found a packet\r\n      packet = bytes.subarray(startIndex, endIndex);\r\n      type = probe.ts.parseType(packet, pmt.pid);\r\n\r\n      switch (type) {\r\n        case 'pat':\r\n          if (!pmt.pid) {\r\n            pmt.pid = probe.ts.parsePat(packet);\r\n          }\r\n          break;\r\n        case 'pmt':\r\n          if (!pmt.table) {\r\n            pmt.table = probe.ts.parsePmt(packet);\r\n          }\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n\r\n      // Found the pat and pmt, we can stop walking the segment\r\n      if (pmt.pid && pmt.table) {\r\n        return;\r\n      }\r\n\r\n      startIndex += MP2T_PACKET_LENGTH;\r\n      endIndex += MP2T_PACKET_LENGTH;\r\n      continue;\r\n    }\r\n\r\n    // If we get here, we have somehow become de-synchronized and we need to step\r\n    // forward one byte at a time until we find a pair of sync bytes that denote\r\n    // a packet\r\n    startIndex++;\r\n    endIndex++;\r\n  }\r\n};\r\n\r\n/**\r\n * walks through the segment data from the start and end to get timing information\r\n * for the first and last audio pes packets\r\n */\r\nvar parseAudioPes_ = function(bytes, pmt, result) {\r\n  var\r\n    startIndex = 0,\r\n    endIndex = MP2T_PACKET_LENGTH,\r\n    packet, type, pesType, pusi, parsed;\r\n\r\n  var endLoop = false;\r\n\r\n  // Start walking from start of segment to get first audio packet\r\n  while (endIndex <= bytes.byteLength) {\r\n    // Look for a pair of start and end sync bytes in the data..\r\n    if (bytes[startIndex] === SYNC_BYTE &&\r\n        (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\r\n      // We found a packet\r\n      packet = bytes.subarray(startIndex, endIndex);\r\n      type = probe.ts.parseType(packet, pmt.pid);\r\n\r\n      switch (type) {\r\n        case 'pes':\r\n          pesType = probe.ts.parsePesType(packet, pmt.table);\r\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\r\n          if (pesType === 'audio' && pusi) {\r\n            parsed = probe.ts.parsePesTime(packet);\r\n            if (parsed) {\r\n              parsed.type = 'audio';\r\n              result.audio.push(parsed);\r\n              endLoop = true;\r\n            }\r\n          }\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n\r\n      if (endLoop) {\r\n        break;\r\n      }\r\n\r\n      startIndex += MP2T_PACKET_LENGTH;\r\n      endIndex += MP2T_PACKET_LENGTH;\r\n      continue;\r\n    }\r\n\r\n    // If we get here, we have somehow become de-synchronized and we need to step\r\n    // forward one byte at a time until we find a pair of sync bytes that denote\r\n    // a packet\r\n    startIndex++;\r\n    endIndex++;\r\n  }\r\n\r\n  // Start walking from end of segment to get last audio packet\r\n  endIndex = bytes.byteLength;\r\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\r\n  endLoop = false;\r\n  while (startIndex >= 0) {\r\n    // Look for a pair of start and end sync bytes in the data..\r\n    if (bytes[startIndex] === SYNC_BYTE &&\r\n        (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\r\n      // We found a packet\r\n      packet = bytes.subarray(startIndex, endIndex);\r\n      type = probe.ts.parseType(packet, pmt.pid);\r\n\r\n      switch (type) {\r\n        case 'pes':\r\n          pesType = probe.ts.parsePesType(packet, pmt.table);\r\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\r\n          if (pesType === 'audio' && pusi) {\r\n            parsed = probe.ts.parsePesTime(packet);\r\n            if (parsed) {\r\n              parsed.type = 'audio';\r\n              result.audio.push(parsed);\r\n              endLoop = true;\r\n            }\r\n          }\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n\r\n      if (endLoop) {\r\n        break;\r\n      }\r\n\r\n      startIndex -= MP2T_PACKET_LENGTH;\r\n      endIndex -= MP2T_PACKET_LENGTH;\r\n      continue;\r\n    }\r\n\r\n    // If we get here, we have somehow become de-synchronized and we need to step\r\n    // forward one byte at a time until we find a pair of sync bytes that denote\r\n    // a packet\r\n    startIndex--;\r\n    endIndex--;\r\n  }\r\n};\r\n\r\n/**\r\n * walks through the segment data from the start and end to get timing information\r\n * for the first and last video pes packets as well as timing information for the first\r\n * key frame.\r\n */\r\nvar parseVideoPes_ = function(bytes, pmt, result) {\r\n  var\r\n    startIndex = 0,\r\n    endIndex = MP2T_PACKET_LENGTH,\r\n    packet, type, pesType, pusi, parsed, frame, i, pes;\r\n\r\n  var endLoop = false;\r\n\r\n  var currentFrame = {\r\n    data: [],\r\n    size: 0\r\n  };\r\n\r\n  // Start walking from start of segment to get first video packet\r\n  while (endIndex < bytes.byteLength) {\r\n    // Look for a pair of start and end sync bytes in the data..\r\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\r\n      // We found a packet\r\n      packet = bytes.subarray(startIndex, endIndex);\r\n      type = probe.ts.parseType(packet, pmt.pid);\r\n\r\n      switch (type) {\r\n        case 'pes':\r\n          pesType = probe.ts.parsePesType(packet, pmt.table);\r\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\r\n          if (pesType === 'video') {\r\n            if (pusi && !endLoop) {\r\n              parsed = probe.ts.parsePesTime(packet);\r\n              if (parsed) {\r\n                parsed.type = 'video';\r\n                result.video.push(parsed);\r\n                endLoop = true;\r\n              }\r\n            }\r\n            if (!result.firstKeyFrame) {\r\n              if (pusi) {\r\n                if (currentFrame.size !== 0) {\r\n                  frame = new Uint8Array(currentFrame.size);\r\n                  i = 0;\r\n                  while (currentFrame.data.length) {\r\n                    pes = currentFrame.data.shift();\r\n                    frame.set(pes, i);\r\n                    i += pes.byteLength;\r\n                  }\r\n                  if (probe.ts.videoPacketContainsKeyFrame(frame)) {\r\n                    var firstKeyFrame = probe.ts.parsePesTime(frame);\r\n\r\n                    // PTS/DTS may not be available. Simply *not* setting\r\n                    // the keyframe seems to work fine with HLS playback\r\n                    // and definitely preferable to a crash with TypeError...\r\n                    if (firstKeyFrame) {\r\n                      result.firstKeyFrame = firstKeyFrame;\r\n                      result.firstKeyFrame.type = 'video';\r\n                    } else {\r\n                      // eslint-disable-next-line\r\n                      console.warn(\r\n                        'Failed to extract PTS/DTS from PES at first keyframe. ' +\r\n                        'This could be an unusual TS segment, or else mux.js did not ' +\r\n                        'parse your TS segment correctly. If you know your TS ' +\r\n                        'segments do contain PTS/DTS on keyframes please file a bug ' +\r\n                        'report! You can try ffprobe to double check for yourself.'\r\n                      );\r\n                    }\r\n                  }\r\n                  currentFrame.size = 0;\r\n                }\r\n              }\r\n              currentFrame.data.push(packet);\r\n              currentFrame.size += packet.byteLength;\r\n            }\r\n          }\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n\r\n      if (endLoop && result.firstKeyFrame) {\r\n        break;\r\n      }\r\n\r\n      startIndex += MP2T_PACKET_LENGTH;\r\n      endIndex += MP2T_PACKET_LENGTH;\r\n      continue;\r\n    }\r\n\r\n    // If we get here, we have somehow become de-synchronized and we need to step\r\n    // forward one byte at a time until we find a pair of sync bytes that denote\r\n    // a packet\r\n    startIndex++;\r\n    endIndex++;\r\n  }\r\n\r\n  // Start walking from end of segment to get last video packet\r\n  endIndex = bytes.byteLength;\r\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\r\n  endLoop = false;\r\n  while (startIndex >= 0) {\r\n    // Look for a pair of start and end sync bytes in the data..\r\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\r\n      // We found a packet\r\n      packet = bytes.subarray(startIndex, endIndex);\r\n      type = probe.ts.parseType(packet, pmt.pid);\r\n\r\n      switch (type) {\r\n        case 'pes':\r\n          pesType = probe.ts.parsePesType(packet, pmt.table);\r\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\r\n          if (pesType === 'video' && pusi) {\r\n              parsed = probe.ts.parsePesTime(packet);\r\n              if (parsed) {\r\n                parsed.type = 'video';\r\n                result.video.push(parsed);\r\n                endLoop = true;\r\n              }\r\n          }\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n\r\n      if (endLoop) {\r\n        break;\r\n      }\r\n\r\n      startIndex -= MP2T_PACKET_LENGTH;\r\n      endIndex -= MP2T_PACKET_LENGTH;\r\n      continue;\r\n    }\r\n\r\n    // If we get here, we have somehow become de-synchronized and we need to step\r\n    // forward one byte at a time until we find a pair of sync bytes that denote\r\n    // a packet\r\n    startIndex--;\r\n    endIndex--;\r\n  }\r\n};\r\n\r\n/**\r\n * Adjusts the timestamp information for the segment to account for\r\n * rollover and convert to seconds based on pes packet timescale (90khz clock)\r\n */\r\nvar adjustTimestamp_ = function(segmentInfo, baseTimestamp) {\r\n  if (segmentInfo.audio && segmentInfo.audio.length) {\r\n    var audioBaseTimestamp = baseTimestamp;\r\n    if (typeof audioBaseTimestamp === 'undefined') {\r\n      audioBaseTimestamp = segmentInfo.audio[0].dts;\r\n    }\r\n    segmentInfo.audio.forEach(function(info) {\r\n      info.dts = handleRollover(info.dts, audioBaseTimestamp);\r\n      info.pts = handleRollover(info.pts, audioBaseTimestamp);\r\n      // time in seconds\r\n      info.dtsTime = info.dts / ONE_SECOND_IN_TS;\r\n      info.ptsTime = info.pts / ONE_SECOND_IN_TS;\r\n    });\r\n  }\r\n\r\n  if (segmentInfo.video && segmentInfo.video.length) {\r\n    var videoBaseTimestamp = baseTimestamp;\r\n    if (typeof videoBaseTimestamp === 'undefined') {\r\n      videoBaseTimestamp = segmentInfo.video[0].dts;\r\n    }\r\n    segmentInfo.video.forEach(function(info) {\r\n      info.dts = handleRollover(info.dts, videoBaseTimestamp);\r\n      info.pts = handleRollover(info.pts, videoBaseTimestamp);\r\n      // time in seconds\r\n      info.dtsTime = info.dts / ONE_SECOND_IN_TS;\r\n      info.ptsTime = info.pts / ONE_SECOND_IN_TS;\r\n    });\r\n    if (segmentInfo.firstKeyFrame) {\r\n      var frame = segmentInfo.firstKeyFrame;\r\n      frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\r\n      frame.pts = handleRollover(frame.pts, videoBaseTimestamp);\r\n      // time in seconds\r\n      frame.dtsTime = frame.dts / ONE_SECOND_IN_TS;\r\n      frame.ptsTime = frame.dts / ONE_SECOND_IN_TS;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * inspects the aac data stream for start and end time information\r\n */\r\nvar inspectAac_ = function(bytes) {\r\n  var\r\n    endLoop = false,\r\n    audioCount = 0,\r\n    sampleRate = null,\r\n    timestamp = null,\r\n    frameSize = 0,\r\n    byteIndex = 0,\r\n    packet;\r\n\r\n  while (bytes.length - byteIndex >= 3) {\r\n    var type = probe.aac.parseType(bytes, byteIndex);\r\n    switch (type) {\r\n      case 'timed-metadata':\r\n        // Exit early because we don't have enough to parse\r\n        // the ID3 tag header\r\n        if (bytes.length - byteIndex < 10) {\r\n          endLoop = true;\r\n          break;\r\n        }\r\n\r\n        frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);\r\n\r\n        // Exit early if we don't have enough in the buffer\r\n        // to emit a full packet\r\n        if (frameSize > bytes.length) {\r\n          endLoop = true;\r\n          break;\r\n        }\r\n        if (timestamp === null) {\r\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\r\n          timestamp = probe.aac.parseAacTimestamp(packet);\r\n        }\r\n        byteIndex += frameSize;\r\n        break;\r\n      case 'audio':\r\n        // Exit early because we don't have enough to parse\r\n        // the ADTS frame header\r\n        if (bytes.length - byteIndex < 7) {\r\n          endLoop = true;\r\n          break;\r\n        }\r\n\r\n        frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);\r\n\r\n        // Exit early if we don't have enough in the buffer\r\n        // to emit a full packet\r\n        if (frameSize > bytes.length) {\r\n          endLoop = true;\r\n          break;\r\n        }\r\n        if (sampleRate === null) {\r\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\r\n          sampleRate = probe.aac.parseSampleRate(packet);\r\n        }\r\n        audioCount++;\r\n        byteIndex += frameSize;\r\n        break;\r\n      default:\r\n        byteIndex++;\r\n        break;\r\n    }\r\n    if (endLoop) {\r\n      return null;\r\n    }\r\n  }\r\n  if (sampleRate === null || timestamp === null) {\r\n    return null;\r\n  }\r\n\r\n  var audioTimescale = ONE_SECOND_IN_TS / sampleRate;\r\n\r\n  var result = {\r\n    audio: [\r\n      {\r\n        type: 'audio',\r\n        dts: timestamp,\r\n        pts: timestamp\r\n      },\r\n      {\r\n        type: 'audio',\r\n        dts: timestamp + (audioCount * 1024 * audioTimescale),\r\n        pts: timestamp + (audioCount * 1024 * audioTimescale)\r\n      }\r\n    ]\r\n  };\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * inspects the transport stream segment data for start and end time information\r\n * of the audio and video tracks (when present) as well as the first key frame's\r\n * start time.\r\n */\r\nvar inspectTs_ = function(bytes) {\r\n  var pmt = {\r\n    pid: null,\r\n    table: null\r\n  };\r\n\r\n  var result = {};\r\n\r\n  parsePsi_(bytes, pmt);\r\n\r\n  for (var pid in pmt.table) {\r\n    if (pmt.table.hasOwnProperty(pid)) {\r\n      var type = pmt.table[pid];\r\n      switch (type) {\r\n        case StreamTypes.H264_STREAM_TYPE:\r\n          result.video = [];\r\n          parseVideoPes_(bytes, pmt, result);\r\n          if (result.video.length === 0) {\r\n            delete result.video;\r\n          }\r\n          break;\r\n        case StreamTypes.ADTS_STREAM_TYPE:\r\n          result.audio = [];\r\n          parseAudioPes_(bytes, pmt, result);\r\n          if (result.audio.length === 0) {\r\n            delete result.audio;\r\n          }\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\n/**\r\n * Inspects segment byte data and returns an object with start and end timing information\r\n *\r\n * @param {Uint8Array} bytes The segment byte data\r\n * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\r\n *  timestamps for rollover. This value must be in 90khz clock.\r\n * @return {Object} Object containing start and end frame timing info of segment.\r\n */\r\nvar inspect = function(bytes, baseTimestamp) {\r\n  var isAacData = probe.aac.isLikelyAacData(bytes);\r\n\r\n  var result;\r\n\r\n  if (isAacData) {\r\n    result = inspectAac_(bytes);\r\n  } else {\r\n    result = inspectTs_(bytes);\r\n  }\r\n\r\n  if (!result || (!result.audio && !result.video)) {\r\n    return null;\r\n  }\r\n\r\n  adjustTimestamp_(result, baseTimestamp);\r\n\r\n  return result;\r\n};\r\n\r\nmodule.exports = {\r\n  inspect: inspect,\r\n  parseAudioPes_: parseAudioPes_\r\n};\r\n"]},"metadata":{},"sourceType":"script"}